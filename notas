

RESTRICCION GARAGE FINISH: Según entiendo la restriccion dice que si no hay garage tampoco se puede construir uno? pero eso seria raro.

RESTRICCION POOLQC: FALTA EL COSTO DE POOR
que pasa con los basement types??


exter qual y exter cond, clasificados por quintiles (cambiar costos)

    # -------------------
    # 4) ROOF: estilo FIJO (no se puede cambiar) y material con costo + compatibilidad
    # -------------------
    style_names = ["Flat", "Gable", "Gambrel", "Hip", "Mansard", "Shed"]
    matl_names  = ["ClyTile", "CompShg", "Membran", "Metal", "Roll", "Tar&Grv", "WdShake", "WdShngl"]

    # binarios ya creados en x (si existen en MODIFIABLE)
    s_bin = {nm: x.get(f"roof_style_is_{nm}") for nm in style_names if f"roof_style_is_{nm}" in x}
    m_bin = {nm: x.get(f"roof_matl_is_{nm}")  for nm in matl_names  if f"roof_matl_is_{nm}"  in x}

    # helper para inyectar gp.Var en X_input (lo usaremos SOLO para materiales)
    def _put_var(df: pd.DataFrame, col: str, var: gp.Var):
        if col in df.columns:
            if df[col].dtype != "O":
                df[col] = df[col].astype("object")
            df.loc[0, col] = var

    # NO inyectamos estilo al X_input -> dejamos los dummies de estilo tal como vienen en X_base

    # Inyectar SOLO dummies de MATERIAL al DataFrame del modelo si existen
    for nm in matl_names:
        col = f"Roof Matl_{nm}"
        if col in X_input.columns and nm in m_bin:
            _put_var(X_input, col, m_bin[nm])

    # estilos prohibidos por compatibilidad según tu matriz
    ROOF_FORBIDS = {
        "Gable":   ["Membran"],
        "Hip":     ["Membran"],
        "Flat":    ["WdShngl", "ClyTile", "CompShg"],
        "Mansard": ["Membran"],
        "Shed":    ["ClyTile"],
        "Gambrel": [],
    }

    # helpers para leer la base (acepta nombres alternativos)
    def _base_val(name, alt=None):
        if name in base_row:
            return str(base_row[name])
        if alt and alt in base_row:
            return str(base_row[alt])
        return None

    base_style = _base_val("RoofStyle", "Roof Style")
    base_mat   = _base_val("RoofMatl",  "Roof Matl")

    # === STYLE: FIJO a la base si la var existe; si no existe, no imponemos nada ===
    if s_bin:
        if base_style in s_bin:
            # estilo fijo: esa binaria =1, el resto =0; el pick-one es seguro en este caso
            s_bin[base_style].LB = s_bin[base_style].UB = 1.0
            for nm, var in s_bin.items():
                if nm != base_style:
                    var.UB = 0.0
            m.addConstr(gp.quicksum(s_bin.values()) == 1, name="ROOF_style_fixed_pick_one")
        # si la var de la base no existe en s_bin, NO añadimos restricciones de estilo

    # === MATERIAL: sí puede cambiar (pick-one siempre que existan) ===
    if m_bin:
        m.addConstr(gp.quicksum(m_bin.values()) == 1, name="ROOF_pick_one_matl")

    # incompatibilidades del material según el estilo BASE (si lo conocemos)
    if m_bin and base_style is not None:
        for mn in ROOF_FORBIDS.get(base_style, []):
            if mn in m_bin:
                m.addConstr(m_bin[mn] == 0.0, name=f"ROOF_incompat_{base_style}_{mn}")

    # costo por cambiar material: demolición + costo del material nuevo (≠ base)
    cost_roof = gp.LinExpr(0.0)
    if m_bin and base_mat is not None and base_mat in m_bin:
        change_ind = 1.0 - m_bin[base_mat]
        cost_roof += ct.roof_demo_cost * change_ind
        for mat, y in m_bin.items():
            if mat != base_mat:
                cost_roof += ct.get_roof_matl_cost(mat) * y
    lin_cost += cost_roof

    # sanity/debug
    _check_onehot("ROOF_style", s_bin, 1 if (s_bin and base_style in s_bin) else None)
    _check_onehot("ROOF_matl", m_bin, 1 if m_bin else None)
    # ================== FIN (ROOF) ==================
