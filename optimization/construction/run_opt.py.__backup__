# optimization/construction/run_opt.py (CLEAN)# -------------------------------------------------------------# Limpio para CONSTRUCCION desde cero# - sin referencias a "remodel"# - objetivo: max precio_predicho - costo_total# - deja hooks para ir agregando restricciones por bloques# -------------------------------------------------------------import argparseimport pandas as pdimport numpy as npimport gurobipy as gpfrom .config import PARAMSfrom .io import get_base_housefrom . import costsfrom .xgb_predictor import XGBBundlefrom .gurobi_model import build_mip_embed, summarize_solution# =====================# helpers simples# =====================def money(v: float) -> str:    try:        f = float(pd.to_numeric(v, errors="coerce"))    except Exception:        return str(v)    if pd.isna(f):        return "-"    return f"${f:,.0f}"def audit_cost_breakdown_vars(m: gp.Model, top: int = 20):    expr = getattr(m, "_lin_cost_expr", None)    if expr is None:        print("[COST-BREAKDOWN] no _lin_cost_expr en el modelo")        return    try:        vs = expr.getVars(); cs = expr.getCoeffs()        X  = m.getAttr("X", vs)    except Exception:        # Fallback: usa _cost_terms si getVars falla        terms = getattr(m, "_cost_terms", [])        if not terms:            print("[COST-BREAKDOWN] no se pudo leer terminos")            return        rows = []        for label, coef, var in terms:            try:                xv = var.X if hasattr(var, "X") else float(var)                contr = float(coef) * float(xv)            except Exception:                continue            # Conserva todos, incluso contribuciones 0, para auditorÃ­a completa            rows.append((label, float(coef), float(xv), contr))        rows.sort(key=lambda t: abs(t[3]), reverse=True)        print("\n[COST-BREAKDOWN] top terminos de costo (fallback):")        for name, c, x, contr in rows[:top]:            print(f"  {name:<35s} coef={c:>10.4f} * X={x:>10.4f}  => {contr:>10.2f}")        # Consistencia: suma de contribuciones vs cost_model        try:            total = sum(contr for _, _, _, contr in rows)            cvar = m.getVarByName("cost_model")            cval = float(getattr(cvar, 'X', float('nan'))) if cvar is not None else float('nan')            print(f"[COST-CHECK] suma_terms={total:,.2f}  | cost_model={cval:,.2f}  | diff={cval-total:,.2f}")        except Exception:            pass        # â€”â€”â€” Resumen por categorÃ­as elegidas (muestra siempre aunque contrib = 0)        try:            coeff_by_var = {}            for name, c, xval, contr in rows:                try:                    v = m.getVarByName(name)  # suele fallar; usa _cost_terms varName                except Exception:                    v = None                # mejor: derivar del label -> varName mediante bÃºsqueda en _cost_terms            for label, c, var in terms:                try:                    coeff_by_var[getattr(var, 'VarName', '')] = (label, float(c))                except Exception:                    pass            def _pick_one(prefix: str, options: list[str]):                chosen = None                for opt in options:                    v = m.getVarByName(f"{prefix}__{opt}")                    if v is not None and getattr(v, 'X', 0.0) > 0.5:                        chosen = (opt, v)                        break                if chosen is None and options:                    # si nada >=0.5, toma el mayor valor igualmente (por seguridad)                    best = (None, None, -1.0)                    for opt in options:                        v = m.getVarByName(f"{prefix}__{opt}")                        if v is not None:                            xv = float(getattr(v, 'X', 0.0))                            if xv > best[2]:                                best = (opt, v, xv)                    chosen = (best[0], best[1])                return chosen            groups: list[tuple[str, list[str]]] = [                ("Heating",   ["Floor","GasA","GasW","Grav","OthW","Wall"]),                ("Electrical",["SBrkr","FuseA","FuseF","FuseP","Mix"]),                ("PavedDrive",["Y","P","N"]),                ("RoofStyle", ["Flat","Gable","Gambrel","Hip","Mansard","Shed"]),                ("RoofMatl",  ["ClyTile","CompShg","Membran","Metal","Roll","Tar&Grv","WdShake","WdShngl"]),                ("Exterior1st",["VinylSd","MetalSd","Wd Sdng","HdBoard","Stucco","Plywood","CemntBd","BrkFace","BrkComm","WdShngl","AsbShng","Stone","ImStucc","AsphShn","CBlock"]),                ("Exterior2nd",["VinylSd","MetalSd","Wd Sdng","HdBoard","Stucco","Plywood","CemntBd","BrkFace","BrkComm","WdShngl","AsbShng","Stone","ImStucc","AsphShn","CBlock"]),                ("Foundation",["BrkTil","CBlock","PConc","Slab","Stone","Wood"]),                ("GarageFinish",["NA","Fin","RFn","Unf"]),                ("Fence",     ["GdPrv","MnPrv","GdWo","MnWw","No aplica"]),                ("MiscFeature",["Elev","Gar2","Othr","Shed","TenC","No aplica"]),            ]            print("\n[COST-CATEGORIES] selecciÃ³n y costo unitario (contrib puede ser 0):")            for gname, opts in groups:                pick = _pick_one(gname, opts)                if pick is None:                    continue                opt, var = pick                xv = float(getattr(var, 'X', 0.0)) if var is not None else 0.0                # Determina coeficiente desde tablas de costos (robusto cuando no hay tÃ©rmino en _cost_terms)                coef = 0.0; contr = 0.0                try:                    if gname == 'Heating' and hasattr(m._ct, 'heating_type_costs'):                        coef = float(m._ct.heating_type_costs.get(opt, 0.0)); contr = coef * xv                    elif gname == 'Electrical' and hasattr(m._ct, 'electrical_type_costs'):                        coef = float(m._ct.electrical_type_costs.get(opt, 0.0)); contr = coef * xv                    elif gname == 'PavedDrive' and hasattr(m._ct, 'paved_drive_costs'):                        coef = float(m._ct.paved_drive_costs.get(opt, 0.0)); contr = coef * xv                    elif gname == 'RoofMatl' and hasattr(m._ct, 'roof_matl_fixed'):                        coef = float(m._ct.roof_matl_fixed.get(opt, 0.0)); contr = coef * xv                    elif gname == 'RoofStyle' and hasattr(m._ct, 'roof_style_costs'):                        coef = float(getattr(m._ct, 'roof_style_costs', {}).get(opt, 0.0)); contr = coef * xv                    elif gname in ('Exterior1st','Exterior2nd') and hasattr(m._ct, 'exterior_matl_lumpsum'):                        coef = float(m._ct.exterior_matl_lumpsum.get(opt, 0.0)); contr = coef * xv                    elif gname == 'GarageFinish' and hasattr(m._ct, 'garage_finish_costs_sqft'):                        coef = float(m._ct.garage_finish_costs_sqft.get(opt if opt != 'NA' else 'No aplica', 0.0)); contr = coef * xv                    elif gname == 'Fence' and hasattr(m._ct, 'fence_category_costs'):                        coef = float(m._ct.fence_category_costs.get(opt, 0.0)); contr = coef * xv                    elif gname == 'MiscFeature' and hasattr(m._ct, 'misc_feature_costs'):                        coef = float(m._ct.misc_feature_costs.get(opt, 0.0)); contr = coef * xv                    elif gname == 'Foundation' and hasattr(m._ct, 'foundation_cost_per_sf'):                        # Foundation es por Ã¡rea: usar FA__{opt}                        z = m.getVarByName(f"FA__{opt}")                        zval = float(getattr(z, 'X', 0.0)) if z is not None else 0.0                        coef = float(m._ct.foundation_cost_per_sf.get(opt, 0.0))                        contr = coef * zval                        print(f"  {gname:<12s} -> {opt:<12s}  coef={coef:>10.4f} * X={zval:>4.1f} => {contr:>10.2f}")                        continue                except Exception:                    coef = 0.0; contr = 0.0                print(f"  {gname:<12s} -> {opt:<12s}  coef={coef:>10.4f} * X={xv:>4.1f} => {contr:>10.2f}")            # Ã¡reas principales (aunque sean 0)            for nm in ("AreaKitchen","AreaFullBath","AreaHalfBath","AreaBedroom",                       "BsmtFin SF 1 @finish","BsmtFin SF 2 @finish",                       "Remainder1 @construction","Remainder2 @construction",                       "AreaOther1 @construction","AreaOther2 @construction"):                # intenta mapear por etiqueta, si no, por nombre de variable                found = [t for t in terms if t[0] == nm]                if found:                    label, coef, var = found[0]                    xv = float(getattr(var, 'X', 0.0))                    contr = float(coef) * xv                    print(f"  {label:<12s}  coef={coef:>10.4f} * X={xv:>8.2f} => {contr:>10.2f}")                else:                    v = m.getVarByName(nm.replace(" @finish","")) or m.getVarByName(nm.replace(" @construction",""))                    if v is not None:                        # encuentra coef si existe                        coef = 0.0                        for lab, c, var in terms:                            if getattr(var, 'VarName', '') == getattr(v, 'VarName', '__'):                                coef = float(c); break                        xv = float(getattr(v, 'X', 0.0))                        print(f"  {nm:<12s}  coef={coef:>10.4f} * X={xv:>8.2f} => {coef*xv:>10.2f}")        except Exception as e:            print("[COST-CATEGORIES] fallo en resumen de categorÃ­as:", e)        return    rows = []    for v, c, x in zip(vs, cs, X):        try:            contrib = float(c) * float(x)        except Exception:            continue        if abs(contrib) > 1e-6:            rows.append((v.VarName, float(c), float(x), contrib))    rows.sort(key=lambda t: abs(t[3]), reverse=True)    print("\n[COST-BREAKDOWN] top terminos de costo:")    for name, c, x, contr in rows[:top]:        print(f"  {name:<35s} coef={c:>10.4f} * X={x:>10.4f}  => {contr:>10.2f}")    # Consistencia con cost_model    try:        total = sum(contr for _, _, _, contr in rows)        cvar = m.getVarByName("cost_model")        cval = float(getattr(cvar, 'X', float('nan'))) if cvar is not None else float('nan')        print(f"[COST-CHECK] suma_terms={total:,.2f}  | cost_model={cval:,.2f}  | diff={cval-total:,.2f}")    except Exception:        passdef audit_predict_outside(m: gp.Model, bundle: XGBBundle):    """Predice fuera de Gurobi con el mismo X_in que vio el embed (si existe)."""    X_in = getattr(m, "_X_input", None)    if X_in is None:        print("[AUDIT] no hay _X_input para predecir fuera")        return    # Soporta el formato dict {order: List[str], x: Dict[str, Var]}    if isinstance(X_in, dict) and "order" in X_in and "x" in X_in:        order = list(X_in["order"])  # tipo: List[str]        xvars = X_in["x"]             # tipo: Dict[str, gp.Var]        import pandas as pd        Z = pd.DataFrame([[0.0]*len(order)], columns=order)        for c in order:            v = xvars.get(c)            if v is None:                # puede existir con nombre aproximado                try:                    v = m.getVarByName(f"x_{c}") or m.getVarByName(f"x_const__{c}")                except Exception:                    v = None            try:                Z.loc[0, c] = float(v.X) if hasattr(v, "X") else float(v)            except Exception:                Z.loc[0, c] = 0.0    else:        # ya viene como DataFrame        Z = X_in.copy()        if getattr(Z, "empty", True):            print("[AUDIT] _X_input vacÃ­o")            return    try:        y_hat = float(bundle.predict(Z).iloc[0])        print(f"[AUDIT] predict fuera = {y_hat:,.2f}")    except Exception as e:        print(f"[AUDIT] fallo predict fuera: {e}")# =====================# main# =====================def main():    ap = argparse.ArgumentParser()    ap.add_argument("--pid", type=int, default=None)    ap.add_argument("--neigh", type=str, default=None)    ap.add_argument("--lot", type=float, default=None)    ap.add_argument("--budget", type=float, required=True)    ap.add_argument("--basecsv", type=str, default=None, help="ruta alternativa al CSV base")    ap.add_argument("--debug-xgb", action="store_true")    ap.add_argument("--fast", action="store_true", help="modo rÃ¡pido (TimeLimit bajo)")    ap.add_argument("--deep", action="store_true", help="modo profundo (TimeLimit alto)")    args = ap.parse_args()    # datos del terreno/barrio, etc (parametros fijos)    def _make_seed_row(neigh: str, lot: float) -> pd.Series:        # valores neutros/seguros para columnas no modificables que el pipeline puede requerir        base_defaults = {            "Neighborhood": neigh or "NAmes",            "LotArea": float(lot or 7000.0),            # opciones tipicas que no deberian bloquear el pipeline            "MS SubClass": 20,            # 1Story 1946+            "MSZoning": "RL",            "Street": "Pave",            "Lot Shape": "Reg",            "LandContour": "Lvl",            "LotConfig": "Inside",            "LandSlope": "Gtl",            "BldgType": "1Fam",            "HouseStyle": "1Story",            "YearBuilt": 2025,            "YearRemodAdd": 2025,            "Foundation": "PConc",            "Condition 1": "Norm",            "Condition 2": "Norm",            "Roof Style": "Gable",            "Garage Cars": 0,            "Low Qual Fin SF": 0,            "Bsmt Qual": "TA",            "Bsmt Full Bath": 0,            "Bsmt Half Bath": 0,            "Month Sold": 6,            "Year Sold": 2025,            "Sale Type": "WD",            "Sale Condition": "Normal",            # areas por defecto 0 para que el MIP las decida            "1st Flr SF": 0.0,            "2nd Flr SF": 0.0,            "Gr Liv Area": 0.0,            "Total Bsmt SF": 0.0,            "Bsmt Unf SF": 0.0,            "BsmtFin SF 1": 0.0,            "BsmtFin SF 2": 0.0,            "Garage Area": 0.0,            "Wood Deck SF": 0.0,            "Open Porch SF": 0.0,            "Enclosed Porch": 0.0,            "3Ssn Porch": 0.0,            "Screen Porch": 0.0,            "Pool Area": 0.0,            "Bedroom AbvGr": 0,            "Full Bath": 0,            "Half Bath": 0,            "Kitchen AbvGr": 0,        }        base_defaults.update({            "OverallQual": 10,            "OverallCond": 10,            "Exter Qual": 4,            "ExterCond": 4,            "Bsmt Qual": 4,            "Heating QC": 4,            "Kitchen Qual": 4,            "Utilities": 3,            "Low Qual Fin SF": 0.0,        })        return pd.Series(base_defaults)    if args.pid is not None:        base = get_base_house(args.pid, base_csv=args.basecsv)        try:            base_row = base.row        except AttributeError:            base_row = base if isinstance(base, pd.Series) else pd.Series(base)    else:        base_row = _make_seed_row(args.neigh, args.lot)    # costos + bundle ML    ct = costs.CostTables()    bundle = XGBBundle()    # construir mip    m: gp.Model = build_mip_embed(base_row=base_row, budget=args.budget, ct=ct, bundle=bundle)    # parametros de solucion    # time limit segÃºn flags    time_limit = PARAMS.time_limit    if args.fast:        time_limit = 60    if args.deep:        time_limit = 900    m.Params.MIPGap         = PARAMS.mip_gap    m.Params.TimeLimit      = time_limit    m.Params.LogToConsole   = PARAMS.log_to_console    m.Params.FeasibilityTol = 1e-7    m.Params.IntFeasTol     = 1e-7    m.Params.OptimalityTol  = 1e-7    m.Params.NumericFocus   = 3    # Ayudas de bÃºsqueda que no sacrifican optimalidad (solo guÃ­an el Ã¡rbol y heurÃ­sticos)    m.Params.MIPFocus       = 1    m.Params.Heuristics     = 0.2    m.Params.Cuts           = 1    m.optimize()        status = int(getattr(m, "Status", -1))    print(f"[STATUS] gurobi Status = {status}")    # debug infeasibilidad o inf_or_unbd    if status in (gp.GRB.INFEASIBLE, gp.GRB.INF_OR_UNBD):        try:            from .gurobi_model import dump_infeasibility_report            tag = f"construction_neigh_{args.neigh}_lot_{args.lot}_budget_{int(args.budget)}"            dump_infeasibility_report(m, tag=tag)        except Exception as e:            print("[DEBUG] fallo dump_infeasibility_report:", e)        # Mensaje especÃ­fico si el budget estÃ¡ en el IIS        try:            m.computeIIS()            flags = [c for c in m.getConstrs() if getattr(c, "IISConstr", 0)]            if any((getattr(c, "ConstrName", "") == "budget") for c in flags):                print("[BUDGET] Presupuesto insuficiente para la construcciÃ³n mÃ­nima.")        except Exception:            pass        # si quieres, puedes salir aqui        return    try:        summarize_solution(m)    except Exception as e:        print(f"[HOUSE SUMMARY] no disponible: {e}")    st = m.Status    if st in (gp.GRB.INF_OR_UNBD, gp.GRB.INFEASIBLE, gp.GRB.UNBOUNDED):        print("\nâŒ modelo infeasible/unbounded. puedes correr m.computeIIS() desde gurobi_model si quieres")        return    if st not in (gp.GRB.OPTIMAL, gp.GRB.TIME_LIMIT) or m.SolCount == 0:        print("\nâš ï¸ no hay solucion valida")        return    # leer solucion    y_var = getattr(m, "_y_price_var", None)    c_var = m.getVarByName("cost_model") or getattr(m, "_cost_var", None)    y_price = float(y_var.X) if y_var is not None else float("nan")    total_cost = float(c_var.X) if c_var is not None else float("nan")    obj = float(getattr(m, "objVal", float("nan")))    print("\n" + "="*60)    print("             RESULTADOS OPTIMIZACION CONSTRUCCION")    print("="*60 + "\n")    print(f"ðŸ“ PID: {base_row.get('PID', 'N/A')} â€“ {base_row.get('Neighborhood', 'N/A')} | Presupuesto: {money(args.budget)}")    print(f"Tiempo: {0:.2f}s | Gap: {1:.4f}%
    print("ðŸ’° resumen economico")    print(f"  Precio predicho (post):  {money(y_price)}")    print(f"  Costos totales modelo:   {money(total_cost)}")    print(f"  Objetivo (utilidad):     {money(obj)}  (= precio - costo)")    try:        budget = float(getattr(m, "_budget_usd", args.budget))        print(f"  Slack presupuesto:       {money(budget - total_cost)}")    except Exception:        pass    # breakdown simple    audit_cost_breakdown_vars(m, top=50)    audit_predict_outside(m, bundle)    print("\n" + "="*60)    print("                     FIN RESULTADOS")    print("="*60 + "\n")if __name__ == "__main__":    main()